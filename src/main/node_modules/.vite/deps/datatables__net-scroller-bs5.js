import {
  dataTables_bootstrap5_default
} from "./chunk-2NA3DSCH.js";
import {
  jquery_dataTables_default
} from "./chunk-LGSEUDT5.js";
import {
  require_jquery
} from "./chunk-OJSIUGB3.js";
import {
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/datatables.net-scroller-bs5/js/scroller.bootstrap5.mjs
var import_jquery2 = __toESM(require_jquery(), 1);

// node_modules/datatables.net-scroller/js/dataTables.scroller.mjs
var import_jquery = __toESM(require_jquery(), 1);
var $ = import_jquery.default;
var Scroller = function(dt, opts) {
  if (!(this instanceof Scroller)) {
    alert("Scroller warning: Scroller must be initialised with the 'new' keyword.");
    return;
  }
  if (opts === void 0) {
    opts = {};
  }
  var dtApi = $.fn.dataTable.Api(dt);
  this.s = {
    /**
     * DataTables settings object
     *  @type     object
     *  @default  Passed in as first parameter to constructor
     */
    dt: dtApi.settings()[0],
    /**
     * DataTables API instance
     *  @type     DataTable.Api
     */
    dtApi,
    /**
     * Pixel location of the top of the drawn table in the viewport
     *  @type     int
     *  @default  0
     */
    tableTop: 0,
    /**
     * Pixel location of the bottom of the drawn table in the viewport
     *  @type     int
     *  @default  0
     */
    tableBottom: 0,
    /**
     * Pixel location of the boundary for when the next data set should be loaded and drawn
     * when scrolling up the way.
     *  @type     int
     *  @default  0
     *  @private
     */
    redrawTop: 0,
    /**
     * Pixel location of the boundary for when the next data set should be loaded and drawn
     * when scrolling down the way. Note that this is actually calculated as the offset from
     * the top.
     *  @type     int
     *  @default  0
     *  @private
     */
    redrawBottom: 0,
    /**
     * Auto row height or not indicator
     *  @type     bool
     *  @default  0
     */
    autoHeight: true,
    /**
     * Number of rows calculated as visible in the visible viewport
     *  @type     int
     *  @default  0
     */
    viewportRows: 0,
    /**
     * setTimeout reference for state saving, used when state saving is enabled in the DataTable
     * and when the user scrolls the viewport in order to stop the cookie set taking too much
     * CPU!
     *  @type     int
     *  @default  0
     */
    stateTO: null,
    stateSaveThrottle: function() {
    },
    /**
     * setTimeout reference for the redraw, used when server-side processing is enabled in the
     * DataTables in order to prevent DoSing the server
     *  @type     int
     *  @default  null
     */
    drawTO: null,
    heights: {
      jump: null,
      page: null,
      virtual: null,
      scroll: null,
      /**
       * Height of rows in the table
       *  @type     int
       *  @default  0
       */
      row: null,
      /**
       * Pixel height of the viewport
       *  @type     int
       *  @default  0
       */
      viewport: null,
      labelHeight: 0,
      xbar: 0
    },
    topRowFloat: 0,
    scrollDrawDiff: null,
    loaderVisible: false,
    forceReposition: false,
    baseRowTop: 0,
    baseScrollTop: 0,
    mousedown: false,
    lastScrollTop: 0
  };
  this.s = $.extend(this.s, Scroller.oDefaults, opts);
  this.s.heights.row = this.s.rowHeight;
  this.dom = {
    force: document.createElement("div"),
    label: $('<div class="dts_label">0</div>'),
    scroller: null,
    table: null,
    loader: null
  };
  if (this.s.dt.oScroller) {
    return;
  }
  this.s.dt.oScroller = this;
  this.construct();
};
$.extend(Scroller.prototype, {
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Public methods - to be exposed via the DataTables API
   */
  /**
   * Calculate and store information about how many rows are to be displayed
   * in the scrolling viewport, based on current dimensions in the browser's
   * rendering. This can be particularly useful if the table is initially
   * drawn in a hidden element - for example in a tab.
   *  @param {bool} [redraw=true] Redraw the table automatically after the recalculation, with
   *    the new dimensions forming the basis for the draw.
   *  @returns {void}
   */
  measure: function(redraw) {
    if (this.s.autoHeight) {
      this._calcRowHeight();
    }
    var heights = this.s.heights;
    if (heights.row) {
      heights.viewport = this._parseHeight($(this.dom.scroller).css("max-height"));
      this.s.viewportRows = parseInt(heights.viewport / heights.row, 10) + 1;
      this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;
    }
    var label = this.dom.label.outerHeight();
    heights.xbar = this.dom.scroller.offsetHeight - this.dom.scroller.clientHeight;
    heights.labelHeight = label;
    if (redraw === void 0 || redraw) {
      this.s.dt.oInstance.fnDraw(false);
    }
  },
  /**
   * Get information about current displayed record range. This corresponds to
   * the information usually displayed in the "Info" block of the table.
   *
   * @returns {object} info as an object:
   *  {
   *      start: {int}, // the 0-indexed record at the top of the viewport
   *      end:   {int}, // the 0-indexed record at the bottom of the viewport
   *  }
   */
  pageInfo: function() {
    var dt = this.s.dt, iScrollTop = this.dom.scroller.scrollTop, iTotal = dt.fnRecordsDisplay(), iPossibleEnd = Math.ceil(
      this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani)
    );
    return {
      start: Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani)),
      end: iTotal < iPossibleEnd ? iTotal - 1 : iPossibleEnd - 1
    };
  },
  /**
   * Calculate the row number that will be found at the given pixel position
   * (y-scroll).
   *
   * Please note that when the height of the full table exceeds 1 million
   * pixels, Scroller switches into a non-linear mode for the scrollbar to fit
   * all of the records into a finite area, but this function returns a linear
   * value (relative to the last non-linear positioning).
   *  @param {int} pixels Offset from top to calculate the row number of
   *  @param {int} [intParse=true] If an integer value should be returned
   *  @param {int} [virtual=false] Perform the calculations in the virtual domain
   *  @returns {int} Row index
   */
  pixelsToRow: function(pixels, intParse, virtual) {
    var diff = pixels - this.s.baseScrollTop;
    var row = virtual ? (this._domain("physicalToVirtual", this.s.baseScrollTop) + diff) / this.s.heights.row : diff / this.s.heights.row + this.s.baseRowTop;
    return intParse || intParse === void 0 ? parseInt(row, 10) : row;
  },
  /**
   * Calculate the pixel position from the top of the scrolling container for
   * a given row
   *  @param {int} iRow Row number to calculate the position of
   *  @returns {int} Pixels
   */
  rowToPixels: function(rowIdx, intParse, virtual) {
    var pixels;
    var diff = rowIdx - this.s.baseRowTop;
    if (virtual) {
      pixels = this._domain("virtualToPhysical", this.s.baseScrollTop);
      pixels += diff * this.s.heights.row;
    } else {
      pixels = this.s.baseScrollTop;
      pixels += diff * this.s.heights.row;
    }
    return intParse || intParse === void 0 ? parseInt(pixels, 10) : pixels;
  },
  /**
   * Calculate the row number that will be found at the given pixel position (y-scroll)
   *  @param {int} row Row index to scroll to
   *  @param {bool} [animate=true] Animate the transition or not
   *  @returns {void}
   */
  scrollToRow: function(row, animate) {
    var that = this;
    var ani = false;
    var px = this.rowToPixels(row);
    var preRows = (this.s.displayBuffer - 1) / 2 * this.s.viewportRows;
    var drawRow = row - preRows;
    if (drawRow < 0) {
      drawRow = 0;
    }
    if ((px > this.s.redrawBottom || px < this.s.redrawTop) && this.s.dt._iDisplayStart !== drawRow) {
      ani = true;
      px = this._domain("virtualToPhysical", row * this.s.heights.row);
      if (this.s.redrawTop < px && px < this.s.redrawBottom) {
        this.s.forceReposition = true;
        animate = false;
      }
    }
    if (animate === void 0 || animate) {
      this.s.ani = ani;
      $(this.dom.scroller).animate(
        {
          scrollTop: px
        },
        function() {
          setTimeout(function() {
            that.s.ani = false;
          }, 250);
        }
      );
    } else {
      $(this.dom.scroller).scrollTop(px);
    }
  },
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Constructor
   */
  /**
   * Initialisation for Scroller
   *  @returns {void}
   *  @private
   */
  construct: function() {
    var that = this;
    var dt = this.s.dtApi;
    if (!this.s.dt.oFeatures.bPaginate) {
      this.s.dt.oApi._fnLog(this.s.dt, 0, "Pagination must be enabled for Scroller");
      return;
    }
    this.dom.force.style.position = "relative";
    this.dom.force.style.top = "0px";
    this.dom.force.style.left = "0px";
    this.dom.force.style.width = "1px";
    this.dom.scroller = $("div." + this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];
    this.dom.scroller.appendChild(this.dom.force);
    this.dom.scroller.style.position = "relative";
    this.dom.table = $(">table", this.dom.scroller)[0];
    this.dom.table.style.position = "absolute";
    this.dom.table.style.top = "0px";
    this.dom.table.style.left = "0px";
    $(dt.table().container()).addClass("dts DTS");
    if (this.s.loadingIndicator) {
      this.dom.loader = $(
        '<div class="dataTables_processing dts_loading">' + this.s.dt.oLanguage.sLoadingRecords + "</div>"
      ).css("display", "none");
      $(this.dom.scroller.parentNode).css("position", "relative").append(this.dom.loader);
    }
    this.dom.label.appendTo(this.dom.scroller);
    if (this.s.heights.row && this.s.heights.row != "auto") {
      this.s.autoHeight = false;
    }
    this.s.ingnoreScroll = true;
    $(this.dom.scroller).on("scroll.dt-scroller", function(e) {
      that._scroll.call(that);
    });
    $(this.dom.scroller).on("touchstart.dt-scroller", function() {
      that._scroll.call(that);
    });
    $(this.dom.scroller).on("mousedown.dt-scroller", function() {
      that.s.mousedown = true;
    }).on("mouseup.dt-scroller", function() {
      that.s.labelVisible = false;
      that.s.mousedown = false;
      that.dom.label.css("display", "none");
    });
    $(window).on("resize.dt-scroller", function() {
      that.measure(false);
      that._info();
    });
    var initialStateSave = true;
    var loadedState = dt.state.loaded();
    dt.on("stateSaveParams.scroller", function(e, settings, data) {
      if (initialStateSave && loadedState) {
        data.scroller = loadedState.scroller;
        initialStateSave = false;
        if (data.scroller) {
          that.s.lastScrollTop = data.scroller.scrollTop;
        }
      } else {
        data.scroller = {
          topRow: that.s.topRowFloat,
          baseScrollTop: that.s.baseScrollTop,
          baseRowTop: that.s.baseRowTop,
          scrollTop: that.s.lastScrollTop
        };
      }
    });
    dt.on("stateLoadParams.scroller", function(e, settings, data) {
      if (data.scroller !== void 0) {
        that.scrollToRow(data.scroller.topRow);
      }
    });
    if (loadedState && loadedState.scroller) {
      this.s.topRowFloat = loadedState.scroller.topRow;
      this.s.baseScrollTop = loadedState.scroller.baseScrollTop;
      this.s.baseRowTop = loadedState.scroller.baseRowTop;
    }
    this.measure(false);
    that.s.stateSaveThrottle = that.s.dt.oApi._fnThrottle(function() {
      that.s.dtApi.state.save();
    }, 500);
    dt.on("init.scroller", function() {
      that.measure(false);
      that.s.scrollType = "jump";
      that._draw();
      dt.on("draw.scroller", function() {
        that._draw();
      });
    });
    dt.on("preDraw.dt.scroller", function() {
      that._scrollForce();
    });
    dt.on("destroy.scroller", function() {
      $(window).off("resize.dt-scroller");
      $(that.dom.scroller).off(".dt-scroller");
      $(that.s.dt.nTable).off(".scroller");
      $(that.s.dt.nTableWrapper).removeClass("DTS");
      $("div.DTS_Loading", that.dom.scroller.parentNode).remove();
      that.dom.table.style.position = "";
      that.dom.table.style.top = "";
      that.dom.table.style.left = "";
    });
  },
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Private methods
   */
  /**
   * Automatic calculation of table row height. This is just a little tricky here as using
   * initialisation DataTables has tale the table out of the document, so we need to create
   * a new table and insert it into the document, calculate the row height and then whip the
   * table out.
   *  @returns {void}
   *  @private
   */
  _calcRowHeight: function() {
    var dt = this.s.dt;
    var origTable = dt.nTable;
    var nTable = origTable.cloneNode(false);
    var tbody = $("<tbody/>").appendTo(nTable);
    var container = $(
      '<div class="' + dt.oClasses.sWrapper + ' DTS"><div class="' + dt.oClasses.sScrollWrapper + '"><div class="' + dt.oClasses.sScrollBody + '"></div></div></div>'
    );
    $("tbody tr:lt(4)", origTable).clone().appendTo(tbody);
    var rowsCount = $("tr", tbody).length;
    if (rowsCount === 1) {
      tbody.prepend("<tr><td>&#160;</td></tr>");
      tbody.append("<tr><td>&#160;</td></tr>");
    } else {
      for (; rowsCount < 3; rowsCount++) {
        tbody.append("<tr><td>&#160;</td></tr>");
      }
    }
    $("div." + dt.oClasses.sScrollBody, container).append(nTable);
    var insertEl = this.s.dt.nHolding || origTable.parentNode;
    if (!$(insertEl).is(":visible")) {
      insertEl = "body";
    }
    container.find("input").removeAttr("name");
    container.appendTo(insertEl);
    this.s.heights.row = $("tr", tbody).eq(1).outerHeight();
    container.remove();
  },
  /**
   * Draw callback function which is fired when the DataTable is redrawn. The main function of
   * this method is to position the drawn table correctly the scrolling container for the rows
   * that is displays as a result of the scrolling position.
   *  @returns {void}
   *  @private
   */
  _draw: function() {
    var that = this, heights = this.s.heights, iScrollTop = this.dom.scroller.scrollTop, iTableHeight = $(this.s.dt.nTable).height(), displayStart = this.s.dt._iDisplayStart, displayLen = this.s.dt._iDisplayLength, displayEnd = this.s.dt.fnRecordsDisplay(), viewportEndY = iScrollTop + heights.viewport;
    this.s.skip = true;
    if ((this.s.dt.bSorted || this.s.dt.bFiltered) && displayStart === 0 && !this.s.dt._drawHold) {
      this.s.topRowFloat = 0;
    }
    iScrollTop = this.s.scrollType === "jump" ? this._domain("virtualToPhysical", this.s.topRowFloat * heights.row) : iScrollTop;
    this.s.baseScrollTop = iScrollTop;
    this.s.baseRowTop = this.s.topRowFloat;
    var tableTop = iScrollTop - (this.s.topRowFloat - displayStart) * heights.row;
    if (displayStart === 0) {
      tableTop = 0;
    } else if (displayStart + displayLen >= displayEnd) {
      tableTop = heights.scroll - iTableHeight;
    } else {
      var iTableBottomY = tableTop + iTableHeight;
      if (iTableBottomY < viewportEndY) {
        var newTableTop = viewportEndY - iTableHeight;
        var diffPx = newTableTop - tableTop;
        this.s.baseScrollTop += diffPx + 1;
        tableTop = newTableTop;
      }
    }
    this.dom.table.style.top = tableTop + "px";
    this.s.tableTop = tableTop;
    this.s.tableBottom = iTableHeight + this.s.tableTop;
    var boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;
    this.s.redrawTop = iScrollTop - boundaryPx;
    this.s.redrawBottom = iScrollTop + boundaryPx > heights.scroll - heights.viewport - heights.row ? heights.scroll - heights.viewport - heights.row : iScrollTop + boundaryPx;
    this.s.skip = false;
    if (that.s.ingnoreScroll) {
      if (this.s.dt.oFeatures.bStateSave && this.s.dt.oLoadedState !== null && typeof this.s.dt.oLoadedState.scroller != "undefined") {
        var ajaxSourced = (this.s.dt.sAjaxSource || that.s.dt.ajax) && !this.s.dt.oFeatures.bServerSide ? true : false;
        if (ajaxSourced && this.s.dt.iDraw >= 2 || !ajaxSourced && this.s.dt.iDraw >= 1) {
          setTimeout(function() {
            $(that.dom.scroller).scrollTop(that.s.dt.oLoadedState.scroller.scrollTop);
            setTimeout(function() {
              that.s.ingnoreScroll = false;
            }, 0);
          }, 0);
        }
      } else {
        that.s.ingnoreScroll = false;
      }
    }
    if (this.s.dt.oFeatures.bInfo) {
      setTimeout(function() {
        that._info.call(that);
      }, 0);
    }
    $(this.s.dt.nTable).triggerHandler("position.dts.dt", tableTop);
    if (this.dom.loader && this.s.loaderVisible) {
      this.dom.loader.css("display", "none");
      this.s.loaderVisible = false;
    }
  },
  /**
   * Convert from one domain to another. The physical domain is the actual
   * pixel count on the screen, while the virtual is if we had browsers which
   * had scrolling containers of infinite height (i.e. the absolute value)
   *
   *  @param {string} dir Domain transform direction, `virtualToPhysical` or
   *    `physicalToVirtual`
   *  @returns {number} Calculated transform
   *  @private
   */
  _domain: function(dir, val) {
    var heights = this.s.heights;
    var diff;
    var magic = 1e4;
    if (heights.virtual === heights.scroll) {
      return val;
    }
    if (val < magic) {
      return val;
    } else if (dir === "virtualToPhysical" && val >= heights.virtual - magic) {
      diff = heights.virtual - val;
      return heights.scroll - diff;
    } else if (dir === "physicalToVirtual" && val >= heights.scroll - magic) {
      diff = heights.scroll - val;
      return heights.virtual - diff;
    }
    var m = (heights.virtual - magic - magic) / (heights.scroll - magic - magic);
    var c = magic - m * magic;
    return dir === "virtualToPhysical" ? (val - c) / m : m * val + c;
  },
  /**
   * Update any information elements that are controlled by the DataTable based on the scrolling
   * viewport and what rows are visible in it. This function basically acts in the same way as
   * _fnUpdateInfo in DataTables, and effectively replaces that function.
   *  @returns {void}
   *  @private
   */
  _info: function() {
    if (!this.s.dt.oFeatures.bInfo) {
      return;
    }
    var dt = this.s.dt, language = dt.oLanguage, iScrollTop = this.dom.scroller.scrollTop, iStart = Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani) + 1), iMax = dt.fnRecordsTotal(), iTotal = dt.fnRecordsDisplay(), iPossibleEnd = Math.ceil(
      this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani)
    ), iEnd = iTotal < iPossibleEnd ? iTotal : iPossibleEnd, sStart = dt.fnFormatNumber(iStart), sEnd = dt.fnFormatNumber(iEnd), sMax = dt.fnFormatNumber(iMax), sTotal = dt.fnFormatNumber(iTotal), sOut;
    if (dt.fnRecordsDisplay() === 0 && dt.fnRecordsDisplay() == dt.fnRecordsTotal()) {
      sOut = language.sInfoEmpty + language.sInfoPostFix;
    } else if (dt.fnRecordsDisplay() === 0) {
      sOut = language.sInfoEmpty + " " + language.sInfoFiltered.replace("_MAX_", sMax) + language.sInfoPostFix;
    } else if (dt.fnRecordsDisplay() == dt.fnRecordsTotal()) {
      sOut = language.sInfo.replace("_START_", sStart).replace("_END_", sEnd).replace("_MAX_", sMax).replace("_TOTAL_", sTotal) + language.sInfoPostFix;
    } else {
      sOut = language.sInfo.replace("_START_", sStart).replace("_END_", sEnd).replace("_MAX_", sMax).replace("_TOTAL_", sTotal) + " " + language.sInfoFiltered.replace("_MAX_", dt.fnFormatNumber(dt.fnRecordsTotal())) + language.sInfoPostFix;
    }
    var callback = language.fnInfoCallback;
    if (callback) {
      sOut = callback.call(dt.oInstance, dt, iStart, iEnd, iMax, iTotal, sOut);
    }
    var n = dt.aanFeatures.i;
    if (typeof n != "undefined") {
      for (var i = 0, iLen = n.length; i < iLen; i++) {
        $(n[i]).html(sOut);
      }
    }
    $(dt.nTable).triggerHandler("info.dt");
  },
  /**
   * Parse CSS height property string as number
   *
   * An attempt is made to parse the string as a number. Currently supported units are 'px',
   * 'vh', and 'rem'. 'em' is partially supported; it works as long as the parent element's
   * font size matches the body element. Zero is returned for unrecognized strings.
   *  @param {string} cssHeight CSS height property string
   *  @returns {number} height
   *  @private
   */
  _parseHeight: function(cssHeight) {
    var height;
    var matches = /^([+-]?(?:\d+(?:\.\d+)?|\.\d+))(px|em|rem|vh)$/.exec(cssHeight);
    if (matches === null) {
      return 0;
    }
    var value = parseFloat(matches[1]);
    var unit = matches[2];
    if (unit === "px") {
      height = value;
    } else if (unit === "vh") {
      height = value / 100 * $(window).height();
    } else if (unit === "rem") {
      height = value * parseFloat($(":root").css("font-size"));
    } else if (unit === "em") {
      height = value * parseFloat($("body").css("font-size"));
    }
    return height ? height : 0;
  },
  /**
   * Scrolling function - fired whenever the scrolling position is changed.
   * This method needs to use the stored values to see if the table should be
   * redrawn as we are moving towards the end of the information that is
   * currently drawn or not. If needed, then it will redraw the table based on
   * the new position.
   *  @returns {void}
   *  @private
   */
  _scroll: function() {
    var that = this, heights = this.s.heights, iScrollTop = this.dom.scroller.scrollTop, iTopRow;
    if (this.s.skip) {
      return;
    }
    if (this.s.ingnoreScroll) {
      return;
    }
    if (iScrollTop === this.s.lastScrollTop) {
      return;
    }
    if (this.s.dt.bFiltered || this.s.dt.bSorted) {
      this.s.lastScrollTop = 0;
      return;
    }
    this._info();
    clearTimeout(this.s.stateTO);
    this.s.stateTO = setTimeout(function() {
      that.s.dtApi.state.save();
    }, 250);
    this.s.scrollType = Math.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport ? "jump" : "cont";
    this.s.topRowFloat = this.s.scrollType === "cont" ? this.pixelsToRow(iScrollTop, false, false) : this._domain("physicalToVirtual", iScrollTop) / heights.row;
    if (this.s.topRowFloat < 0) {
      this.s.topRowFloat = 0;
    }
    if (this.s.forceReposition || iScrollTop < this.s.redrawTop || iScrollTop > this.s.redrawBottom) {
      var preRows = Math.ceil((this.s.displayBuffer - 1) / 2 * this.s.viewportRows);
      iTopRow = parseInt(this.s.topRowFloat, 10) - preRows;
      this.s.forceReposition = false;
      if (iTopRow <= 0) {
        iTopRow = 0;
      } else if (iTopRow + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay()) {
        iTopRow = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;
        if (iTopRow < 0) {
          iTopRow = 0;
        }
      } else if (iTopRow % 2 !== 0) {
        iTopRow++;
      }
      this.s.targetTop = iTopRow;
      if (iTopRow != this.s.dt._iDisplayStart) {
        this.s.tableTop = $(this.s.dt.nTable).offset().top;
        this.s.tableBottom = $(this.s.dt.nTable).height() + this.s.tableTop;
        var draw = function() {
          that.s.dt._iDisplayStart = that.s.targetTop;
          that.s.dt.oApi._fnDraw(that.s.dt);
        };
        if (this.s.dt.oFeatures.bServerSide) {
          this.s.forceReposition = true;
          clearTimeout(this.s.drawTO);
          this.s.drawTO = setTimeout(draw, this.s.serverWait);
        } else {
          draw();
        }
        if (this.dom.loader && !this.s.loaderVisible) {
          this.dom.loader.css("display", "block");
          this.s.loaderVisible = true;
        }
      }
    } else {
      this.s.topRowFloat = this.pixelsToRow(iScrollTop, false, true);
    }
    this.s.lastScrollTop = iScrollTop;
    this.s.stateSaveThrottle();
    if (this.s.scrollType === "jump" && this.s.mousedown) {
      this.s.labelVisible = true;
    }
    if (this.s.labelVisible) {
      var labelFactor = (heights.viewport - heights.labelHeight - heights.xbar) / heights.scroll;
      this.dom.label.html(this.s.dt.fnFormatNumber(parseInt(this.s.topRowFloat, 10) + 1)).css("top", iScrollTop + iScrollTop * labelFactor).css("display", "block");
    }
  },
  /**
   * Force the scrolling container to have height beyond that of just the
   * table that has been drawn so the user can scroll the whole data set.
   *
   * Note that if the calculated required scrolling height exceeds a maximum
   * value (1 million pixels - hard-coded) the forcing element will be set
   * only to that maximum value and virtual / physical domain transforms will
   * be used to allow Scroller to display tables of any number of records.
   *  @returns {void}
   *  @private
   */
  _scrollForce: function() {
    var heights = this.s.heights;
    var max = 1e6;
    heights.virtual = heights.row * this.s.dt.fnRecordsDisplay();
    heights.scroll = heights.virtual;
    if (heights.scroll > max) {
      heights.scroll = max;
    }
    this.dom.force.style.height = heights.scroll > this.s.heights.row ? heights.scroll + "px" : this.s.heights.row + "px";
  }
});
Scroller.defaults = {
  /**
   * Scroller uses the boundary scaling factor to decide when to redraw the table - which it
   * typically does before you reach the end of the currently loaded data set (in order to
   * allow the data to look continuous to a user scrolling through the data). If given as 0
   * then the table will be redrawn whenever the viewport is scrolled, while 1 would not
   * redraw the table until the currently loaded data has all been shown. You will want
   * something in the middle - the default factor of 0.5 is usually suitable.
   *  @type     float
   *  @default  0.5
   *  @static
   */
  boundaryScale: 0.5,
  /**
   * The display buffer is what Scroller uses to calculate how many rows it should pre-fetch
   * for scrolling. Scroller automatically adjusts DataTables' display length to pre-fetch
   * rows that will be shown in "near scrolling" (i.e. just beyond the current display area).
   * The value is based upon the number of rows that can be displayed in the viewport (i.e.
   * a value of 1), and will apply the display range to records before before and after the
   * current viewport - i.e. a factor of 3 will allow Scroller to pre-fetch 1 viewport's worth
   * of rows before the current viewport, the current viewport's rows and 1 viewport's worth
   * of rows after the current viewport. Adjusting this value can be useful for ensuring
   * smooth scrolling based on your data set.
   *  @type     int
   *  @default  7
   *  @static
   */
  displayBuffer: 9,
  /**
   * Show (or not) the loading element in the background of the table. Note that you should
   * include the dataTables.scroller.css file for this to be displayed correctly.
   *  @type     boolean
   *  @default  false
   *  @static
   */
  loadingIndicator: false,
  /**
   * Scroller will attempt to automatically calculate the height of rows for it's internal
   * calculations. However the height that is used can be overridden using this parameter.
   *  @type     int|string
   *  @default  auto
   *  @static
   */
  rowHeight: "auto",
  /**
   * When using server-side processing, Scroller will wait a small amount of time to allow
   * the scrolling to finish before requesting more data from the server. This prevents
   * you from DoSing your own server! The wait time can be configured by this parameter.
   *  @type     int
   *  @default  200
   *  @static
   */
  serverWait: 200
};
Scroller.oDefaults = Scroller.defaults;
Scroller.version = "2.2.0";
$(document).on("preInit.dt.dtscroller", function(e, settings) {
  if (e.namespace !== "dt") {
    return;
  }
  var init = settings.oInit.scroller;
  var defaults = jquery_dataTables_default.defaults.scroller;
  if (init || defaults) {
    var opts = $.extend({}, init, defaults);
    if (init !== false) {
      new Scroller(settings, opts);
    }
  }
});
$.fn.dataTable.Scroller = Scroller;
$.fn.DataTable.Scroller = Scroller;
var Api = $.fn.dataTable.Api;
Api.register("scroller()", function() {
  return this;
});
Api.register("scroller().rowToPixels()", function(rowIdx, intParse, virtual) {
  var ctx = this.context;
  if (ctx.length && ctx[0].oScroller) {
    return ctx[0].oScroller.rowToPixels(rowIdx, intParse, virtual);
  }
});
Api.register("scroller().pixelsToRow()", function(pixels, intParse, virtual) {
  var ctx = this.context;
  if (ctx.length && ctx[0].oScroller) {
    return ctx[0].oScroller.pixelsToRow(pixels, intParse, virtual);
  }
});
Api.register(["scroller().scrollToRow()", "scroller.toPosition()"], function(idx, ani) {
  this.iterator("table", function(ctx) {
    if (ctx.oScroller) {
      ctx.oScroller.scrollToRow(idx, ani);
    }
  });
  return this;
});
Api.register("row().scrollTo()", function(ani) {
  var that = this;
  this.iterator("row", function(ctx, rowIdx) {
    if (ctx.oScroller) {
      var displayIdx = that.rows({ order: "applied", search: "applied" }).indexes().indexOf(rowIdx);
      ctx.oScroller.scrollToRow(displayIdx, ani);
    }
  });
  return this;
});
Api.register("scroller.measure()", function(redraw) {
  this.iterator("table", function(ctx) {
    if (ctx.oScroller) {
      ctx.oScroller.measure(redraw);
    }
  });
  return this;
});
Api.register("scroller.page()", function() {
  var ctx = this.context;
  if (ctx.length && ctx[0].oScroller) {
    return ctx[0].oScroller.pageInfo();
  }
});

// node_modules/datatables.net-scroller-bs5/js/scroller.bootstrap5.mjs
var scroller_bootstrap5_default = dataTables_bootstrap5_default;
export {
  scroller_bootstrap5_default as default
};
/*! Bundled license information:

datatables.net-scroller/js/dataTables.scroller.mjs:
  (*! Scroller 2.2.0
   * © SpryMedia Ltd - datatables.net/license
   *)

datatables.net-scroller-bs5/js/scroller.bootstrap5.mjs:
  (*! Bootstrap 5 styling wrapper for Scroller
   * © SpryMedia Ltd - datatables.net/license
   *)
*/
//# sourceMappingURL=datatables__net-scroller-bs5.js.map
